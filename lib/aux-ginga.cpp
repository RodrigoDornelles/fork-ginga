/* Copyright (C) 2006-2017 PUC-Rio/Laboratorio TeleMidia

This file is part of Ginga (Ginga-NCL).

Ginga is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

Ginga is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
License for more details.

You should have received a copy of the GNU General Public License
along with Ginga.  If not, see <http://www.gnu.org/licenses/>.  */

#include "aux-ginga.h"

GINGA_PRAGMA_DIAG_IGNORE (-Wimplicit-fallthrough)


// Logging -----------------------------------------------------------------

/**
 * @brief Parses G_STRFUNC string to generate a log prefix.
 * @param strfunc String generated by G_STRFUNC macro.
 * @return Log prefix.
 */
string
__ginga_strfunc (const string &strfunc)
{
  string result;
  size_t i;

  i = strfunc.find ("(");
  g_assert (i != std::string::npos);
  result = strfunc.substr (0, i);

  i = result.rfind (" ");
  if (i != std::string::npos)
    result = result.substr (i + 1);

  return result + "()";
}


// Parsing and evaluation --------------------------------------------------

/**
 * @brief Parses boolean string.
 * @param s Boolean string.
 * @param result Variable to store the resulting boolean.
 * @return True if successful, or false otherwise.
 */
bool
_ginga_parse_bool (const string &s, bool *result)
{
  if (xstrcaseeq (s, "true"))
    {
      tryset (result, true);
      return true;
    }
  else if (xstrcaseeq (s, "false"))
    {
      tryset (result, false);
      return true;
    }
  else
    {
      return false;
    }
}

/**
 * @brief Parses color string.
 * @param s Color string.
 * @param result Variable to store the resulting color.
 * @return True if successful, or false otherwise.
 */
bool
_ginga_parse_color (const string &s, GingaColor *result)
{
  if (s == "")
    {
      GingaColor none = {0,0,0,0};
      tryset (result, none);
      return true;
    }
  else
    {
      return gdk_rgba_parse (result, s.c_str ());
    }
}

/**
 * @brief Parses list of string items.
 * @param s List string.
 * @param sep Separator.
 * @param min Minimum number of items.
 * @param max Maximum number of items.
 * @param result Variable to store the resulting items.
 * @return True if successful, or false otherwise.
 */
bool
_ginga_parse_list (const string &s, char sep, size_t min, size_t max,
                   vector<string> *result)
{
  vector<string> items;
  size_t n;

  items = xstrsplit (s, sep);
  n = items.size ();
  if (n < min || n > max)
    return false;

  for (size_t i = 0; i < n; i++)
    items[i] = xstrstrip (items[i]);

  tryset (result, items);
  return true;
}

/**
 * @brief Parses number or percent string to an integer.
 * @param s Number or percent string.
 * @param base Base value used to convert percent to integer.
 * @param min Minimum resulting integer.
 * @param max Maximum resulting integer.
 * @return The resulting integer.
 */
int
ginga_parse_percent (const string &s, int base, int min, int max)
{
  bool percent;
  double d;
  int result;

  d = xstrtodorpercent (s, &percent);
  if (percent)
    {
      result = (int) lround (d * base);
    }
  else
    {
      result = (int) lround (d);
    }
  return (int) CLAMP (result, min, max);
}

/**
 * Parses time string ("Ns" or "NN:NN:NN").
 * @param s Time string.
 * @param result Variable to store the resulting time.
 * @return True if successful, or false otherwise.
 */
bool
_ginga_parse_time (const string &s, GingaTime *result)
{
  gchar *dup;
  gchar *end;
  double secs;

  dup = g_strdup (s.c_str ());
  g_strchomp (dup);

  secs = g_strtod (dup, &end);
  if (*end == '\0' || g_str_equal (end, "s"))
    goto success;

  if (*end != ':')
    goto failure;

  end++;
  secs = 3600 * secs + 60 * g_strtod (end, &end);
  if (*end != ':')
    goto failure;

  end++;
  secs += g_strtod (end, &end);
  if (*end != '\0')
    goto failure;

 success:
  g_free (dup);
  tryset (result, (GingaTime)(secs * GINGA_SECOND));
  return true;

 failure:
  g_free (dup);
  return false;
}

// Asserted wrappers for _ginga_parse_*.
#define _GINGA_PARSE_DEFN(Type, Name, Str)                      \
  Type                                                          \
  ginga_parse_##Name (const string &s)                          \
  {                                                             \
    Type result;                                                \
    if (unlikely (!_ginga_parse_##Name (s, &result)))           \
      ERROR_SYNTAX ("invalid %s string '%s'", Str, s.c_str ()); \
    return result;                                              \
  }

_GINGA_PARSE_DEFN (bool, bool, "boolean")
_GINGA_PARSE_DEFN (GingaColor, color, "color")
_GINGA_PARSE_DEFN (GingaTime, time, "time")

vector<string>
ginga_parse_list (const string &s, char sep, size_t min, size_t max)
{
  vector<string> result;
  if (unlikely (!_ginga_parse_list (s, sep, min, max, &result)))
    ERROR_SYNTAX ("invalid list string '%s'", s.c_str ());
  return result;
}

/**
 * @brief Parses comparator string.
 * @param s Comparator string.
 * @param result Variable to store the resulting comparator.
 * @return True if success, or false otherwise.
 */
bool
_ginga_parse_comparator (const string &s, string *result)
{
  if (xstrcaseeq (s, "eq")
      || xstrcaseeq (s, "ne")
      || xstrcaseeq (s, "lt")
      || xstrcaseeq (s, "lte")
      || xstrcaseeq (s, "gt")
      || xstrcaseeq (s, "gte"))
    {
      tryset (result, xstrdown (s));
      return true;
    }
  else
    {
      return false;
    }
}

/**
 * @brief Evaluates comparator with the given operands.
 * @param s Operator ("eq", "ne", "lt", "lte", "gt", or "gte").
 * @param a First operand.
 * @param b Second operand.
 */
bool
ginga_eval_comparator (const string &s, const string &a, const string &b)
{
  string comp;

  g_assert (_ginga_parse_comparator (s, &comp));

  if (comp == "eq")
    {
      if (a == b)
        return true;
    }
  else if (comp == "ne")
    {
      if (a != b)
        return true;
    }
  else if (comp == "lt")
    {
      if (a.compare (b) < 0)
        return true;
    }
  else if (comp == "lte")
    {
      if (a.compare (b) <= 0)
        return true;
    }
  else if (comp == "gt")
    {
      if (a.compare (b) > 0)
        return true;
    }
  else if (comp == "gte")
    {
      if (a.compare (b) >= 0)
        return true;
    }
  else
    g_assert_not_reached ();

  return false;
}


// Strings -----------------------------------------------------------------

/**
 * @brief Converts string to a floating-point number.
 * @param s Number string.
 * @param dp Variable to store the resulting floating-point number.
 * @return True if successful, or false otherwise.
 */
bool
_xstrtod (const string &s, double *dp)
{
  const gchar *c_str;
  gchar *endptr;
  double d;

  c_str = s.c_str ();
  d = g_ascii_strtod (c_str, &endptr);
  if (endptr == c_str)
    return false;

  tryset (dp, d);
  return true;
}

/**
 * @brief Converts string to a 64-bit integer.
 * @param s Number string.
 * @param ip Variable to store the resulting integer.
 * @param base The base to be used in the conversion.
 * @return True if successful, or false otherwise.
 */
bool
_xstrtoll (const string &s, gint64 *ip, guint base)
{
  const gchar *c_str;
  gchar *endptr;
  gint64 i;

  c_str = s.c_str ();
  i = g_ascii_strtoll (c_str, &endptr, base);
  if (endptr == c_str)
    return false;

  tryset (ip, i);
  return true;
}

/**
 * @brief Converts string to an unsigned 64-bit integer.
 * @param s Number string.
 * @param ip Variable to store the resulting unsigned integer.
 * @param base The base to be used in the conversion.
 * @return True if successful, or false otherwise.
 */
bool
_xstrtoull (const string &s, guint64 *ip, guint base)
{
  const gchar *c_str;
  gchar *endptr;
  guint64 u;

  c_str = s.c_str ();
  u = g_ascii_strtoull (c_str, &endptr, base);
  if (endptr == c_str)
    return false;

  tryset (ip, u);
  return true;
}

// Asserted wrappers for _xstrtod, _xstrtoll, and _xstrtoull.
double
xstrtod (const string &s)
{
  double d;
  g_assert (_xstrtod (s, &d));
  return d;
}

#define _GINGA_XSTRTO_DEFN(Type, Typemin, Typemax)      \
  g##Type                                               \
  xstrto##Type (const string &s, guint8 base)           \
  {                                                     \
    gint64 x=0;                                         \
    g_assert (_xstrtoll (s, &x, base));                 \
    return (g##Type)(CLAMP (x, Typemin, Typemax));      \
  }

_GINGA_XSTRTO_DEFN (int,    G_MININT,    G_MAXINT)
_GINGA_XSTRTO_DEFN (int8,   G_MININT8,   G_MAXINT8)
_GINGA_XSTRTO_DEFN (int64,  G_MININT64,  G_MAXINT64)

#define _GINGA_XSTRTOU_DEFN(Type, Typemax)              \
  g##Type                                               \
  xstrto##Type (const string &s, guint8 base)           \
  {                                                     \
    guint64 x=0;                                        \
    g_assert (_xstrtoull (s, &x, base));                \
    return (g##Type)(MIN (x, Typemax));                 \
  }

_GINGA_XSTRTOU_DEFN (uint,   G_MAXUINT)
_GINGA_XSTRTOU_DEFN (uint8,  G_MAXUINT8)
_GINGA_XSTRTOU_DEFN (uint64, G_MAXUINT64)

/**
 * @brief Checks if string is a percent value.
 * @param s Value string.
 * @return True if successful, or false otherwise.
 */
bool
xstrispercent (const string &s)
{
  const gchar *str = s.c_str ();
  gchar *end;

  if (str[0] == '%')
    return false;

  g_ascii_strtod (str, &end);
  return *end == '%';
}

/**
 * @brief Converts number or percent string to floating-point number.
 * @param s Number or percent string.
 * @param perc Variable to store whether the converted value is a number or
 * percent value.
 * @result The resulting number.
 */
// Converts a number or percent string to a number.
gdouble
xstrtodorpercent (const string &s, bool *perc)
{
  gchar *end;
  gdouble x = g_ascii_strtod (s.c_str (), &end);
  if (*end == '%')
    {
      tryset (perc, true);
      return x / 100.;
    }
  else
    {
      tryset (perc, false);
      return x;
    }
}

/**
 * @brief Compares two strings ignoring case.
 * @param s1 First string.
 * @param s2 Second string.
 * @return -1, 0, or 1
 */
int
xstrcasecmp (const string &s1, const string &s2)
{
  return g_ascii_strcasecmp (s1.c_str (), s2.c_str ());
}

/**
 * @brief Tests string string prefix.
 * @param s String.
 * @param prefix Prefix.
 * @return True if successful, or false otherwise.
 */
bool
xstrhasprefix (const string &s, const string &prefix)
{
  return g_str_has_prefix (s.c_str (), prefix.c_str ());
}

/**
 * @brief Tests if string suffix.
 * @param s String.
 * @param suffix Suffix.
 * @return True if successful, or false otherwise.
 */
bool
xstrhassuffix (const string &s, const string &suffix)
{
  return g_str_has_suffix (s.c_str (), suffix.c_str ());
}

/**
 * @brief Assigns format to string.
 * @param s Resulting string.
 * @param format Format string.
 * @return The number of bytes assigned.
 */
int
xstrassign (string &s, const char *format, ...)
{
  va_list args;
  char *c_str = NULL;
  int n;

  va_start (args, format);
  n = g_vasprintf (&c_str, format, args);
  va_end (args);

  g_assert (n >= 0);
  g_assert_nonnull (c_str);
  s.assign (c_str);
  g_free (c_str);

  return n;
}

/**
 * @brief Builds string from format.
 * @param format Format string.
 * @return The resulting string.
 */
string
xstrbuild (const char *format, ...)
{
  va_list args;
  char *c_str = NULL;
  int n;
  string s;

  va_start (args, format);
  n = g_vasprintf (&c_str, format, args);
  va_end (args);

  g_assert (n >= 0);
  g_assert_nonnull (c_str);
  s.assign (c_str);
  g_free (c_str);

  return s;
}

/**
 * @brief Converts string to uppercase.
 */
string
xstrup (string s)
{
  gchar *dup = g_ascii_strup (s.c_str (), (gssize) s.size ());
  s.assign (dup);
  free (dup);
  return s;
}

/**
 * @brief Converts string to lowercase.
 */
string
xstrdown (string s)
{
  gchar *dup = g_ascii_strdown (s.c_str (), (gssize) s.size ());
  s.assign (dup);
  free (dup);
  return s;
}

/**
 * @brief Removes leading and trailing whitespace from string.
 */
string
xstrstrip (string s)
{
  gchar *dup = g_strdup (s.c_str ());
  s.assign (g_strstrip (dup));
  g_free (dup);
  return s;
}

/**
 * @brief Splits strings according to separator.
 * @param s String.
 * @param sep Separator.
 * @return The resulting vector.
 */
vector<string>
xstrsplit (const string &s, char sep)
{
  vector<string> result;
  stringstream ss (s);
  string tok;

  while (getline (ss, tok, sep))
    result.push_back (tok);

  return result;
}


// Paths -------------------------------------------------------------------

/**
 * @brief Returns the basename of path.
 */
string
xpathbasename (string path)
{
  gchar *dir = g_path_get_basename (path.c_str ());
  path.assign (dir);
  g_free (dir);
  return path;
}

/**
 * @brief Returns the dirname of path.
 */
string
xpathdirname (string path)
{
  gchar *dir = g_path_get_dirname (path.c_str ());
  path.assign (dir);
  g_free (dir);
  return path;
}

/**
 * @brief Checks if path is absolute.
 */
bool
xpathisabs (const string &path)
{
  return g_path_is_absolute (path.c_str ());
}

/**
 * @brief Checks if path is an URI.
 */
bool
xpathisuri (const string &path)
{
  gchar * dup  = g_uri_parse_scheme (path.c_str ());
  return (dup == NULL) ? false : (g_free (dup), true);
}

/**
 * @brief Makes path absolute.
 */
string
xpathmakeabs (string path)
{
  if (!xpathisabs (path))
    {
      gchar *cwd = g_get_current_dir ();
      gchar *dup = g_build_filename (cwd, path.c_str (), NULL);
      g_free (cwd);
      path.assign (dup);
      g_free (dup);
    }
  return path;
}

/**
 * @brief Builds a path from the given components.
 */
string
xpathbuild (const string &a, const string &b)
{
  string path;
  gchar *dup = g_build_filename (a.c_str (), b.c_str (), NULL);
  path.assign (dup);
  g_free (dup);
  return path;
}

/**
 * @brief Builds an absolute path from the given components.
 */
string
xpathbuildabs (const string &a, const string &b)
{
  return xpathmakeabs (xpathbuild (a, b));
}


// OpenGL ------------------------------------------------------------------

#if defined WITH_OPENGL && WITH_OPENGL

#if defined WITH_OPENGLES2 && WITH_OPENGLES2
auto vertexSource =
    "uniform vec2 winSize;\n"
    "\n"
    "in vec2 pos;\n"
    "in vec4 color;\n"
    "in vec2 texcoord;\n"
    "\n"
    "out vec4 f_color;\n"
    "out vec2 f_texcoord;\n"
    "void main() {\n"
    "   pos.x = ((pos.x)/winSize.x) * 2.0f - 1.0;\n"
    "   pos.y = ((pos.y)/winSize.y) * (-2.0f) + 1.0f;\n"
    "   gl_Position = vec4 ( pos.x, pos.y, 0.0, 1.0);\n"
    "   f_texcoord = texcoord;\n"
    "   f_color = color;\n"
    "}\n";

static auto fragmentSource =
    "uniform int use_tex;\n"
    "uniform sampler2D tex;\n"
    "\n"
    "in vec4 f_color;\n"
    "in vec2 f_texcoord;\n"
    "\n"
    "out vec4 outColor;\n"
    "void main() {\n"
    "   vec4 t0 = texture2D(tex, f_texcoord);\n"
    "   outColor = use_tex * t0 * f_color + "
    "              (1.0-use_tex) * f_color;\n"
    "}\n";

struct GLES2Ctx
{
  GLuint vertexShader, fragmentShader, shaderProgram;

  // Buffers
  GLuint vbo;
  GLuint ebo;

  // Attributes
  GLint posAttr;
  GLint colorAttr;
  GLint texAttr;
};

static struct GLES2Ctx gles2ctx;

struct sprite {
  GLfloat pos [2];
  GLfloat v_color [4];
  GLfloat tex_coords [2];
};

static struct sprite vertices[] = {
  {{0.0f, 0.0f}, {1.0, 1.0, 1.0, 1.0}, {0.0f, 0.0f}},
  {{400.0f, 0.0f}, {1.0, 1.0, 1.0, 1.0}, {1.0f, 0.0f}},
  {{400.0f, 400.0f}, {1.0, 1.0, 1.0, 1.0}, {1.0f, 1.0f}},
  {{0.0f, 400.0f}, {1.0, 1.0, 1.0, 1.0}, {0.0f, 1.0f}} };

static GLuint elements[] = {
  0, 1, 2,
  2, 3, 0
};
#endif

void
gl_init ()
{
#if defined WITH_OPENGLES2 && WITH_OPENGLES2
  glGenBuffers (1, &gles2ctx.vbo);
  glBindBuffer (GL_ARRAY_BUFFER, gles2ctx.vbo);
  glBufferData (GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

  glGenBuffers (1, &gles2ctx.ebo);
  glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, gles2ctx.ebo);
  glBufferData (GL_ELEMENT_ARRAY_BUFFER, sizeof (elements), elements,
                GL_STATIC_DRAW);

  gles2ctx.vertexShader = glCreateShader (GL_VERTEX_SHADER);
  glShaderSource (gles2ctx.vertexShader, 1, &vertexSource, nullptr);
  glCompileShader (gles2ctx.vertexShader);

  gles2ctx.fragmentShader = glCreateShader (GL_FRAGMENT_SHADER);
  glShaderSource (gles2ctx.fragmentShader, 1, &fragmentSource, nullptr);
  glCompileShader (gles2ctx.fragmentShader);

  gles2ctx.shaderProgram = glCreateProgram ();
  glAttachShader (gles2ctx.shaderProgram, gles2ctx.vertexShader);
  glAttachShader (gles2ctx.shaderProgram, gles2ctx.fragmentShader);
  glLinkProgram (gles2ctx.shaderProgram);
  glUseProgram (gles2ctx.shaderProgram);

  gles2ctx.posAttr = glGetAttribLocation (gles2ctx.shaderProgram, "pos");
  if (gles2ctx.posAttr < 0)
    WARNING ("Shader pos attribute not found.");

  gles2ctx.colorAttr = glGetAttribLocation (gles2ctx.shaderProgram, "color");
  if (gles2ctx.colorAttr < 0)
    WARNING ("Shader color attribute not found.");

  gles2ctx.texAttr = glGetAttribLocation (gles2ctx.shaderProgram, "texcoord");
  if (gles2ctx.texAttr < 0)
    WARNING ("Shader texcoord attribute not found.");

#endif

  CHECK_GL_ERROR ();
}

/**
 * @brief gl_clear_scene Clear and configure OpenGL context
 */
void
gl_clear_scene (int w, int h)
{
  glViewport (0.0, 0.0, w, h);

#if WITH_OPENGLES2
  GLuint loc = glGetUniformLocation (gles2ctx.shaderProgram, "winSize");
  g_assert (loc != -1);
  glUniform2f (loc, w, h);
  loc = glGetUniformLocation (gles2ctx.shaderProgram, "use_tex");
  glUniform1i (loc, 0);
#else
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  glOrtho (0.0, w, h, 0.0, 0.0, 1.0);
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity();
#endif

  glClearColor (0.0f, 0.0f, 0.0f, 1.0f);
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glEnable (GL_BLEND);
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glBlendEquation (GL_FUNC_ADD);

  glEnable (GL_TEXTURE_2D);
}

/**
 * @brief gl_create_texture Creates a new uninitialized OpenGL texture.
 */
void
gl_create_texture (GLuint *gltex)
{
  glGenTextures (1, gltex);
  glBindTexture (GL_TEXTURE_2D, *gltex);

  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

  CHECK_GL_ERROR ();
}

/**
 * @brief gl_create_texture Creates a new OpenGL texture and initializes it with
 *  the data content.
 */
void
gl_create_texture (GLuint *gltex, int tex_w, int tex_h, unsigned char *data)
{
  gl_create_texture (gltex);
  glTexImage2D (GL_TEXTURE_2D, 0, 4,
                tex_w, tex_h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

  CHECK_GL_ERROR ();
}

/**
 * @brief gl_delete_texture Deletes the texture.
 */
void
gl_delete_texture (GLuint *gltex)
{
  if (*gltex != (GLuint) -1)
    {
      glDeleteTextures (1, gltex);
    }

  CHECK_GL_ERROR ();
}

/**
 * @brief gl_update_texture Updates texture with the data content.
 */
void
gl_update_texture (GLuint gltex, int tex_w, int tex_h, unsigned char *data)
{
  glActiveTexture (gltex);
  glTexImage2D (GL_TEXTURE_2D, 0, 4,
                tex_w, tex_h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

  CHECK_GL_ERROR ();
}

/**
 * @brief gl_update_subtexture Updates subtexture with the data content.
 */
void
gl_update_subtexture (GLuint gltex,
                      int xoffset, int yoffset, int width, int height,
                      unsigned char *data)
{
  glBindTexture (GL_TEXTURE_2D, gltex);
  glTexSubImage2D (GL_TEXTURE_2D,
                   0,
                   xoffset,
                   yoffset,
                   width,
                   height,
                   GL_RGBA,
                   GL_UNSIGNED_BYTE,
                   data);

  CHECK_GL_ERROR ();
}

/**
 * @brief gl_draw_quad Draws a textured rectangle
 */
void
gl_draw_quad (int x, int y, int w, int h, GLuint gltex, GLfloat alpha)
{
  g_assert (gltex > 0);
  glBindTexture (GL_TEXTURE_2D, gltex);
#if WITH_OPENGLES2
  GLuint loc = glGetUniformLocation (gles2ctx.shaderProgram, "use_tex");
  glUniform1i (loc, 1);

  vertices[0].pos[0] = x; vertices[0].pos[1] = y;
  vertices[0].v_color[0] = 1.0;
  vertices[0].v_color[1] = 1.0;
  vertices[0].v_color[2] = 1.0;
  vertices[0].v_color[3] = alpha;

  vertices[1].pos[0] = x + w; vertices[1].pos[1] = y;
  vertices[1].v_color[0] = 1.0;
  vertices[1].v_color[1] = 1.0;
  vertices[1].v_color[2] = 1.0;
  vertices[1].v_color[3] = alpha;

  vertices[2].pos[0] = x + w; vertices[2].pos[1] = y + h;
  vertices[2].v_color[0] = 1.0;
  vertices[2].v_color[1] = 1.0;
  vertices[2].v_color[2] = 1.0;
  vertices[2].v_color[3] = alpha;

  vertices[3].pos[0] = x; vertices[3].pos[1] = y + h;
  vertices[3].v_color[0] = 1.0;
  vertices[3].v_color[1] = 1.0;
  vertices[3].v_color[2] = 1.0;
  vertices[3].v_color[3] = alpha;

  glBufferData (GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

  glEnableVertexAttribArray (gles2ctx.posAttr);
  glVertexAttribPointer (gles2ctx.posAttr, 2, GL_FLOAT, GL_FALSE,
                         sizeof (struct sprite),
                         0);

  glEnableVertexAttribArray (gles2ctx.colorAttr);
  glVertexAttribPointer (gles2ctx.colorAttr, 4, GL_FLOAT, GL_FALSE,
                         sizeof (struct sprite),
                         (GLvoid*) (2 * sizeof (GLfloat)));

  glEnableVertexAttribArray (gles2ctx.texAttr);
  glVertexAttribPointer (gles2ctx.texAttr, 2, GL_FLOAT, GL_FALSE,
                         sizeof (struct sprite),
                         (GLvoid*) (6 * sizeof (GLfloat)) );

  glEnable (GL_BLEND);
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glBlendEquation (GL_FUNC_ADD);

  // glDrawArrays (GL_TRIANGLES, 0, 3);
  glDrawElements (GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
#else
  glColor4f (1.0f, 1.0f, 1.0f, alpha);
  glBegin( GL_QUADS );
    glTexCoord2d (0.0,0.0); glVertex2d (x, y);
    glTexCoord2d (1.0,0.0); glVertex2d (x + w, y);
    glTexCoord2d (1.0,1.0); glVertex2d (x + w, y + h);
    glTexCoord2d (0.0,1.0); glVertex2d (x, y + h);
  glEnd();
#endif
  glBindTexture (GL_TEXTURE_2D, 0);

  CHECK_GL_ERROR ();
}

/**
 * @brief gl_draw_quad Draws a colored rectangle
 */
void
gl_draw_quad (int x, int y, int w, int h,
              GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
#if WITH_OPENGLES2
  GLuint loc = glGetUniformLocation (gles2ctx.shaderProgram, "use_tex");
  glUniform1i (loc, 0);

  vertices[0].pos[0] = x; vertices[0].pos[1] = y;
  vertices[0].v_color[0] = r;
  vertices[0].v_color[1] = g;
  vertices[0].v_color[2] = b;
  vertices[0].v_color[3] = a;

  vertices[1].pos[0] = x + w; vertices[1].pos[1] = y;
  vertices[1].v_color[0] = r;
  vertices[1].v_color[1] = g;
  vertices[1].v_color[2] = b;
  vertices[1].v_color[3] = a;

  vertices[2].pos[0] = x + w; vertices[2].pos[1] = y + h;
  vertices[2].v_color[0] = r;
  vertices[2].v_color[1] = g;
  vertices[2].v_color[2] = b;
  vertices[2].v_color[3] = a;

  vertices[3].pos[0] = x; vertices[3].pos[1] = y + h;
  vertices[3].v_color[0] = r;
  vertices[3].v_color[1] = g;
  vertices[3].v_color[2] = b;
  vertices[3].v_color[3] = a;

  glBufferData (GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

  glDrawElements (GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
#else
  glColor4f (r, g, b, a);
  glBegin (GL_QUADS);
    glVertex2d (x, y);
    glVertex2d (x + w, y);
    glVertex2d (x + w, y + h);
    glVertex2d (x, y + h);
  glEnd();
#endif
  CHECK_GL_ERROR ();
}

#endif

